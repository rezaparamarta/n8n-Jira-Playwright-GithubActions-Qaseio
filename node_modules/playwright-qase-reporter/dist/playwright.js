"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.qase = exports.ReporterContentType = void 0;
const test_1 = __importDefault(require("@playwright/test"));
const uuid_1 = require("uuid");
const reporter_1 = require("./reporter");
const path = __importStar(require("path"));
const qase_javascript_commons_1 = require("qase-javascript-commons");
exports.ReporterContentType = 'application/qase.metadata+json';
const defaultContentType = 'application/octet-stream';
/**
 * Set IDs for the test case
 *
 * @param caseId
 * @param name
 * @example
 * test(qase(1, 'test'), async ({ page }) => {
 *  await page.goto('https://example.com');
 * });
 * @returns {string}
 */
const qase = (caseId, name) => {
    const caseIds = Array.isArray(caseId) ? caseId : [caseId];
    const ids = [];
    for (const id of caseIds) {
        if (typeof id === 'number') {
            ids.push(id);
            continue;
        }
        const parsedId = parseInt(id);
        if (!isNaN(parsedId)) {
            ids.push(parsedId);
            continue;
        }
        console.log(`qase: qase ID ${id} should be a number`);
    }
    const newName = `${name} (Qase ID: ${caseIds.join(',')})`;
    reporter_1.PlaywrightQaseReporter.addIds(ids, newName);
    return newName;
};
exports.qase = qase;
/**
 * Set IDs for the test case
 * Use `qase()` instead. This method is deprecated and kept for reverse compatibility.
 *
 * @param {number | number[]} value
 *
 * @example
 * test('test', async ({ page }) => {
 *    qase.id(1);
 *    await page.goto('https://example.com');
 * });
 *
 */
exports.qase.id = function (value) {
    addMetadata({
        ids: Array.isArray(value) ? value : [value],
    });
    return this;
};
/**
 * Set multi-project mapping: project code -> test case IDs (for testops_multi mode).
 * @param mapping — e.g. { PROJ1: [1, 2], PROJ2: [3] }
 * @example
 * test('test', async ({ page }) => {
 *   qase.projects({ PROJ1: [1, 2], PROJ2: [3] });
 *   await page.goto('https://example.com');
 * });
 */
exports.qase.projects = function (mapping) {
    const normalized = {};
    for (const [code, ids] of Object.entries(mapping)) {
        if (Array.isArray(ids) && ids.length > 0) {
            normalized[code] = ids.map((id) => (typeof id === 'number' ? id : parseInt(String(id), 10))).filter((n) => !Number.isNaN(n));
        }
    }
    if (Object.keys(normalized).length > 0) {
        addMetadata({ projectMapping: normalized });
    }
    return this;
};
/**
 * Return test title with multi-project markers (for testops_multi mode).
 * Use as the test name: test(qase.projectsTitle('Test name', { PROJ1: [1], PROJ2: [2] }), () => { ... }).
 * @param name — base test title
 * @param mapping — project code → test case IDs, e.g. { PROJ1: [1], PROJ2: [2] }
 */
exports.qase.projectsTitle = function (name, mapping) {
    const normalized = {};
    for (const [code, ids] of Object.entries(mapping)) {
        if (Array.isArray(ids) && ids.length > 0) {
            normalized[code] = ids.map((id) => (typeof id === 'number' ? id : parseInt(String(id), 10))).filter((n) => !Number.isNaN(n));
        }
    }
    return Object.keys(normalized).length > 0 ? (0, qase_javascript_commons_1.formatTitleWithProjectMapping)(name, normalized) : name;
};
/**
 * Set a title for the test case
 * @param {string} value
 * @example
 * test('test', async ({ page }) => {
 *    qase.title("Title");
 *    await page.goto('https://example.com');
 * });
 */
exports.qase.title = function (value) {
    addMetadata({
        title: value,
    });
    return this;
};
/**
 * Set fields for the test case
 * @param {Record<string, string>[]} values
 * @example
 * test('test', async ({ page }) => {
 *    qase.fields({ 'severity': 'high', 'priority': 'medium' });
 *    await page.goto('https://example.com');
 * });
 */
exports.qase.fields = function (values) {
    const stringRecord = {};
    for (const [key, value] of Object.entries(values)) {
        stringRecord[String(key)] = String(value);
    }
    addMetadata({
        fields: stringRecord,
    });
    return this;
};
/**
 * Set parameters for the test case
 * @param {Record<string, string>[]} values
 * @example
 * for (const value of values) {
 *    test('test', async ({ page }) => {
 *      qase.parameters({ 'parameter': value });
 *      await page.goto('https://example.com');
 *    });
 * )
 */
exports.qase.parameters = function (values) {
    const stringRecord = {};
    for (const [key, value] of Object.entries(values)) {
        stringRecord[String(key)] = String(value);
    }
    addMetadata({
        parameters: stringRecord,
    });
    return this;
};
/**
 * Set group parameters for the test case.
 * All parameters will be grouped as a single entity.
 * @param {Record<string, string>[]} values
 * @example
 * for (const value of values) {
 *    test('test', async ({ page }) => {
 *      qase.groupParameters({ 'parameter': value });
 *      await page.goto('https://example.com');
 *    });
 * )
 */
exports.qase.groupParameters = function (values) {
    const stringRecord = {};
    for (const [key, value] of Object.entries(values)) {
        stringRecord[String(key)] = String(value);
    }
    addMetadata({
        groupParams: stringRecord,
    });
    return this;
};
/**
 * Attach a file to the test case or the step
 * @param attach
 * @example
 * test('test', async ({ page }) => {
 *   qase.attach({ name: 'attachment.txt', content: 'Hello, world!', contentType: 'text/plain' });
 *   qase.attach({ paths: '/path/to/file'});
 *   qase.attach({ paths: ['/path/to/file', '/path/to/another/file']});
 *   await page.goto('https://example.com');
 *  });
 */
exports.qase.attach = function (attach) {
    if (attach.paths !== undefined) {
        const files = Array.isArray(attach.paths) ? attach.paths : [attach.paths];
        for (const file of files) {
            const attachmentName = path.basename(file);
            const contentType = (0, qase_javascript_commons_1.getMimeTypes)(file);
            addAttachment(attachmentName, contentType, file);
        }
        return this;
    }
    const attachmentName = attach.name ?? 'attachment';
    const contentType = attach.contentType ?? defaultContentType;
    addAttachment(attachmentName, contentType, undefined, attach.content);
    return this;
};
/**
 * Ignore the test case result in Qase
 * @example
 * test('test', async ({ page }) => {
 *   qase.ignore();
 *   await page.goto('https://example.com');
 * });
 */
exports.qase.ignore = function () {
    addMetadata({
        ignore: true,
    });
    return this;
};
/**
 * Set a suite for the test case
 * @param {string} value
 * @example
 * test('test', async ({ page }) => {
 *    qase.suite("Suite");
 *    await page.goto('https://example.com');
 * });
 */
exports.qase.suite = function (value) {
    addMetadata({
        suite: value,
    });
    return this;
};
/**
 * Set a comment for the test case
 * @param {string} value
 * @example
 * test('test', async ({ page }) => {
 *    qase.comment("Comment");
 *    await page.goto('https://example.com');
 * });
 */
exports.qase.comment = function (value) {
    addMetadata({
        comment: value,
    });
    return this;
};
/**
 * Set a expected result and data for the test step
 * @param action
 * @param expectedResult
 * @param data
 * @example
 * test('test', async ({ page }) => {
 *    await test.step(qase.step('action', 'expected result', 'data'), async () => {
 *      await page.goto('https://example.com');
 *    });
 * });
 */
exports.qase.step = function (action, expectedResult, data) {
    return `${action} QaseExpRes:${expectedResult ? `: ${expectedResult}` : ''} QaseData:${data ? `: ${data}` : ''}`;
};
const addMetadata = (metadata) => {
    test_1.default.info().attach('qase-metadata.json', {
        contentType: exports.ReporterContentType,
        body: Buffer.from(JSON.stringify(metadata), 'utf8'),
    }).catch(() => {
    });
};
const addAttachment = (name, contentType, filePath, body) => {
    const stepName = filePath != undefined ? `step_attach_file_${(0, uuid_1.v4)()}_${name}` : `step_attach_body_${(0, uuid_1.v4)()}_${name}`;
    test_1.default.step(stepName, async () => {
        if (filePath) {
            await test_1.default.info().attach(stepName, {
                contentType: contentType,
                body: filePath,
            });
        }
        if (body) {
            await test_1.default.info().attach(stepName, {
                contentType: contentType,
                body: body,
            });
        }
    }).catch(() => {
    });
};
