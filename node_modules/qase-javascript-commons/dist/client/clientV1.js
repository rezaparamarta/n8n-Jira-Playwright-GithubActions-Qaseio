"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ClientV1 = void 0;
const qase_api_client_1 = require("qase-api-client");
const is_axios_error_1 = require("../utils/is-axios-error");
const qase_error_1 = require("../utils/qase-error");
const chalk_1 = __importDefault(require("chalk"));
const fs_1 = require("fs");
const dateUtils_1 = require("./dateUtils");
const form_data_1 = __importDefault(require("form-data"));
const DEFAULT_API_HOST = 'qase.io';
const API_BASE_URL = 'https://api-';
const APP_BASE_URL = 'https://';
const API_VERSION = '/v1';
// Attachment upload limits
const MAX_FILE_SIZE = 32 * 1024 * 1024; // 32 MB per file
const MAX_REQUEST_SIZE = 128 * 1024 * 1024; // 128 MB per request
const MAX_FILES_PER_REQUEST = 20; // 20 files per request
var ApiErrorCode;
(function (ApiErrorCode) {
    ApiErrorCode[ApiErrorCode["UNAUTHORIZED"] = 401] = "UNAUTHORIZED";
    ApiErrorCode[ApiErrorCode["FORBIDDEN"] = 403] = "FORBIDDEN";
    ApiErrorCode[ApiErrorCode["NOT_FOUND"] = 404] = "NOT_FOUND";
    ApiErrorCode[ApiErrorCode["BAD_REQUEST"] = 400] = "BAD_REQUEST";
    ApiErrorCode[ApiErrorCode["UNPROCESSABLE_ENTITY"] = 422] = "UNPROCESSABLE_ENTITY";
})(ApiErrorCode || (ApiErrorCode = {}));
class ClientV1 {
    logger;
    config;
    environment;
    appUrl;
    runClient;
    environmentClient;
    attachmentClient;
    configurationClient;
    constructor(logger, config, environment) {
        this.logger = logger;
        this.config = config;
        this.environment = environment;
        const { apiConfig, appUrl } = this.createApiConfig();
        this.appUrl = appUrl;
        this.runClient = new qase_api_client_1.RunsApi(apiConfig);
        this.environmentClient = new qase_api_client_1.EnvironmentsApi(apiConfig);
        this.attachmentClient = new qase_api_client_1.AttachmentsApi(apiConfig);
        this.configurationClient = new qase_api_client_1.ConfigurationsApi(apiConfig);
    }
    createApiConfig() {
        const apiConfig = new qase_api_client_1.Configuration({ apiKey: this.config.api.token, formDataCtor: form_data_1.default });
        if (this.config.api.host && this.config.api.host != DEFAULT_API_HOST) {
            apiConfig.basePath = `${API_BASE_URL}${this.config.api.host}${API_VERSION}`;
            return { apiConfig, appUrl: `${APP_BASE_URL}${this.config.api.host}` };
        }
        apiConfig.basePath = `https://api.${DEFAULT_API_HOST}${API_VERSION}`;
        return { apiConfig, appUrl: `https://app.${DEFAULT_API_HOST}` };
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    uploadResults(_runId, _results) {
        throw new Error('Use ClientV2 to upload results');
    }
    async createRun() {
        if (this.config.run.id) {
            return this.config.run.id;
        }
        try {
            // Handle configurations if provided
            let configurationIds = [];
            if (this.config.configurations) {
                configurationIds = await this.handleConfigurations();
            }
            const environmentId = await this.getEnvironmentId();
            const runObject = this.prepareRunObject(environmentId, configurationIds);
            this.logger.logDebug(`Creating test run: ${JSON.stringify(runObject)}`);
            const { data } = await this.runClient.createRun(this.config.project, runObject);
            if (!data.result?.id) {
                throw new qase_error_1.QaseError('Failed to create test run');
            }
            this.logger.logDebug(`Test run created: ${JSON.stringify(data)}`);
            if (this.config.run.externalLink && data.result.id) {
                // Map our enum values to API enum values
                // eslint-disable-next-line @typescript-eslint/no-unsafe-enum-comparison
                const apiType = this.config.run.externalLink.type === 'jiraCloud'
                    ? qase_api_client_1.RunExternalIssuesTypeEnum.JIRA_CLOUD
                    : qase_api_client_1.RunExternalIssuesTypeEnum.JIRA_SERVER;
                await this.runClient.runUpdateExternalIssue(this.config.project, {
                    type: apiType,
                    links: [
                        {
                            run_id: data.result.id,
                            external_issue: this.config.run.externalLink.link,
                        },
                    ],
                });
            }
            return data.result.id;
        }
        catch (error) {
            throw this.processError(error, 'Error creating test run');
        }
    }
    async completeRun(runId) {
        if (!this.config.run.complete) {
            return;
        }
        try {
            await this.runClient.completeRun(this.config.project, runId);
        }
        catch (error) {
            throw this.processError(error, 'Error on completing run');
        }
        if (this.appUrl) {
            const runUrl = `${this.appUrl}/run/${this.config.project}/dashboard/${runId}`;
            this.logger.log((0, chalk_1.default) `{blue Test run link: ${runUrl}}`);
        }
    }
    async enablePublicReport(runId) {
        try {
            const { data } = await this.runClient.updateRunPublicity(this.config.project, runId, { status: true });
            if (data.result?.url) {
                this.logger.log((0, chalk_1.default) `{blue Public report link: ${data.result.url}}`);
            }
        }
        catch (error) {
            this.logger.log((0, chalk_1.default) `{yellow Failed to generate public report link: ${this.getErrorMessage(error)}}`);
        }
    }
    getErrorMessage(error) {
        if ((0, is_axios_error_1.isAxiosError)(error)) {
            const err = error;
            const errorData = err.response?.data;
            return errorData?.errorMessage ?? errorData?.error ?? errorData?.message ?? 'Unknown API error';
        }
        return error instanceof Error ? error.message : 'Unknown error';
    }
    async uploadAttachment(attachment) {
        try {
            const data = this.prepareAttachmentData(attachment);
            const response = await this.attachmentClient.uploadAttachment(this.config.project, [data]);
            return response.data.result?.[0]?.hash ?? '';
        }
        catch (error) {
            throw this.processError(error, 'Error on uploading attachment');
        }
    }
    async uploadAttachments(attachments) {
        if (!this.config.uploadAttachments) {
            return [];
        }
        const uploadedHashes = [];
        // Filter out invalid attachments and check file size limits
        const validAttachments = [];
        for (const attachment of attachments) {
            if (!attachment) {
                continue;
            }
            // Ensure attachment size is calculated if not set or is 0
            this.ensureAttachmentSize(attachment);
            // Skip attachments with unknown size (0)
            if (attachment.size === 0) {
                this.logger.logError(`Cannot determine size for attachment "${attachment.file_path ?? attachment.file_name}". Skipping.`);
                continue;
            }
            // Check if file exceeds maximum size per file (32 MB)
            if (attachment.size > MAX_FILE_SIZE) {
                this.logger.logError(`Attachment "${attachment.file_path ?? attachment.file_name}" exceeds maximum file size (32 MB). ` +
                    `File size: ${(attachment.size / (1024 * 1024)).toFixed(2)} MB. Skipping.`);
                continue;
            }
            validAttachments.push(attachment);
        }
        if (validAttachments.length === 0) {
            return uploadedHashes;
        }
        // Add initial random delay to spread out requests from different workers/shard
        // This helps prevent all workers from hitting the API at the same time
        const initialJitter = Math.random() * 500; // 0-500ms random delay
        await this.delay(initialJitter);
        // Group attachments into batches that respect API limits
        const batches = this.groupAttachmentsIntoBatches(validAttachments);
        this.logger.logDebug(`Uploading ${validAttachments.length} attachments in ${batches.length} batch(es)`);
        // Upload each batch
        for (let i = 0; i < batches.length; i++) {
            const batch = batches[i];
            if (!batch || batch.length === 0) {
                continue;
            }
            try {
                const batchNames = batch.map(a => a.file_path ?? a.file_name).join(', ');
                this.logger.logDebug(`Uploading batch ${i + 1}/${batches.length} with ${batch.length} file(s): ${batchNames}`);
                const batchData = batch.map(attachment => this.prepareAttachmentData(attachment));
                const response = await this.uploadAttachmentWithRetry(this.config.project, batchData, batchNames);
                // Extract all hashes from the response
                if (response.data.result) {
                    for (const result of response.data.result) {
                        if (result.hash) {
                            uploadedHashes.push(result.hash);
                        }
                    }
                }
            }
            catch (error) {
                this.logger.logError(`Cannot upload batch ${i + 1}:`, error);
                // Continue with next batch even if current batch fails
            }
            // Add delay between batches to avoid rate limiting
            // Skip delay after the last batch
            if (i < batches.length - 1) {
                // Increased delay with random jitter to prevent synchronization
                const baseDelay = 1000; // 1000ms (1 second) base delay
                const jitter = Math.random() * 300; // 0-300ms random jitter
                await this.delay(baseDelay + jitter);
            }
        }
        return uploadedHashes;
    }
    /**
     * Group attachments into batches respecting API limits:
     * - Up to 20 files per batch
     * - Up to 128 MB per batch
     * @param attachments Array of attachments to group
     * @returns Array of attachment batches
     */
    groupAttachmentsIntoBatches(attachments) {
        const batches = [];
        let currentBatch = [];
        let currentBatchSize = 0;
        for (const attachment of attachments) {
            const attachmentSize = attachment.size;
            // Check if adding this attachment would exceed limits
            const wouldExceedFileLimit = currentBatch.length >= MAX_FILES_PER_REQUEST;
            const wouldExceedSizeLimit = currentBatchSize + attachmentSize > MAX_REQUEST_SIZE;
            // If current batch is full or would exceed limits, start a new batch
            if (wouldExceedFileLimit || wouldExceedSizeLimit) {
                if (currentBatch.length > 0) {
                    batches.push(currentBatch);
                    currentBatch = [];
                    currentBatchSize = 0;
                }
            }
            // If a single file exceeds request size limit, it should have been filtered earlier
            // but we check again as a safety measure
            if (attachmentSize > MAX_REQUEST_SIZE) {
                this.logger.logError(`Attachment "${attachment.file_path ?? attachment.file_name}" exceeds maximum request size (128 MB). ` +
                    `File size: ${(attachmentSize / (1024 * 1024)).toFixed(2)} MB. Skipping.`);
                continue;
            }
            currentBatch.push(attachment);
            currentBatchSize += attachmentSize;
        }
        // Add the last batch if it's not empty
        if (currentBatch.length > 0) {
            batches.push(currentBatch);
        }
        return batches;
    }
    /**
     * Upload attachment with retry logic for 429 errors
     * @param project Project code
     * @param data Attachment data array (can contain multiple files)
     * @param attachmentNames Attachment names for logging (comma-separated for batches)
     * @param maxRetries Maximum number of retry attempts
     * @param initialDelay Initial delay in milliseconds
     * @returns Promise with upload response
     */
    async uploadAttachmentWithRetry(project, data, attachmentNames, maxRetries = 5, initialDelay = 1000) {
        let lastError;
        let delay = initialDelay;
        for (let attempt = 0; attempt <= maxRetries; attempt++) {
            try {
                return await this.attachmentClient.uploadAttachment(project, data);
            }
            catch (error) {
                lastError = error;
                // Check if it's a 429 error (Too Many Requests)
                if ((0, is_axios_error_1.isAxiosError)(error)) {
                    if (error.response?.status === 429) {
                        if (attempt < maxRetries) {
                            const retryAfter = this.getRetryAfter(error);
                            const baseWaitTime = retryAfter ?? delay;
                            // Add jitter (random delay) to prevent all workers from retrying simultaneously
                            // Jitter is 10-30% of the wait time to spread out retry attempts
                            const jitterPercent = 0.1 + Math.random() * 0.2; // 10-30%
                            const jitter = baseWaitTime * jitterPercent;
                            const waitTime = Math.floor(baseWaitTime + jitter);
                            this.logger.logDebug(`Rate limit exceeded (429) for attachment(s) "${attachmentNames}". ` +
                                `Retrying in ${waitTime}ms (attempt ${attempt + 1}/${maxRetries})`);
                            await this.delay(waitTime);
                            // Exponential backoff: double the delay for next attempt
                            delay = Math.min(delay * 2, 30000); // Cap at 30 seconds
                        }
                        else {
                            this.logger.logError(`Failed to upload attachment(s) "${attachmentNames}" after ${maxRetries} retries due to rate limiting`);
                        }
                    }
                    else {
                        // For non-429 errors, throw immediately
                        throw error;
                    }
                }
                else {
                    // For non-Axios errors, throw immediately
                    throw error;
                }
            }
        }
        // If we exhausted all retries, throw the last error
        throw lastError;
    }
    /**
     * Extract Retry-After header value from response or return null
     * @param error Axios error
     * @returns Retry-After value in milliseconds or null
     */
    getRetryAfter(error) {
        const headers = error.response?.headers;
        if (!headers) {
            return null;
        }
        const retryAfterHeader = headers['retry-after'];
        if (retryAfterHeader && typeof retryAfterHeader === 'string') {
            const retryAfterSeconds = parseInt(retryAfterHeader, 10);
            if (!isNaN(retryAfterSeconds)) {
                return retryAfterSeconds * 1000; // Convert to milliseconds
            }
        }
        return null;
    }
    /**
     * Delay execution for specified milliseconds
     * @param ms Milliseconds to delay
     */
    delay(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }
    /**
     * Ensure attachment size is calculated if not set or is 0
     * @param attachment Attachment to ensure size for
     */
    ensureAttachmentSize(attachment) {
        // If size is already set and greater than 0, use it
        if (attachment.size > 0) {
            return;
        }
        try {
            if (attachment.file_path) {
                // Get file size from file system
                const stats = (0, fs_1.statSync)(attachment.file_path);
                attachment.size = stats.size;
            }
            else if (attachment.content) {
                // Calculate size from content
                if (typeof attachment.content === 'string') {
                    // For strings, check if it's base64 encoded
                    if (attachment.content.match(/^[A-Za-z0-9+/=]+$/)) {
                        // Base64 encoded string
                        attachment.size = Buffer.from(attachment.content, 'base64').length;
                    }
                    else {
                        // Regular string - use byte length
                        attachment.size = Buffer.byteLength(attachment.content, 'utf8');
                    }
                }
                else if (Buffer.isBuffer(attachment.content)) {
                    // Buffer - use length
                    attachment.size = attachment.content.length;
                }
                else {
                    // Fallback: try to convert to string and get byte length
                    attachment.size = Buffer.byteLength(String(attachment.content), 'utf8');
                }
            }
        }
        catch (error) {
            // If we can't determine size, log warning and set to 0
            this.logger.logDebug(`Could not determine size for attachment "${attachment.file_path ?? attachment.file_name}": ${error instanceof Error ? error.message : 'Unknown error'}`);
            attachment.size = 0;
        }
    }
    prepareAttachmentData(attachment) {
        if (attachment.file_path) {
            return {
                name: attachment.file_name,
                value: (0, fs_1.createReadStream)(attachment.file_path),
            };
        }
        return {
            name: attachment.file_name,
            value: typeof attachment.content === 'string'
                ? Buffer.from(attachment.content, attachment.content.match(/^[A-Za-z0-9+/=]+$/) ? 'base64' : undefined)
                : attachment.content,
        };
    }
    async getEnvironmentId() {
        if (!this.environment)
            return undefined;
        const { data } = await this.environmentClient.getEnvironments(this.config.project, undefined, this.environment, 100);
        return data.result?.entities?.find((env) => env.slug === this.environment)?.id;
    }
    prepareRunObject(environmentId, configurationIds) {
        const runObject = {
            title: this.config.run.title ?? `Automated run ${new Date().toISOString()}`,
            description: this.config.run.description ?? '',
            is_autotest: true,
            cases: [],
            start_time: (0, dateUtils_1.getStartTime)(),
            tags: this.config.run.tags ?? [],
        };
        if (environmentId !== undefined) {
            runObject.environment_id = environmentId;
        }
        if (this.config.plan.id) {
            runObject.plan_id = this.config.plan.id;
        }
        if (configurationIds && configurationIds.length > 0) {
            runObject.configurations = configurationIds;
        }
        return runObject;
    }
    /**
     * Get all configuration groups with their configurations
     * @returns Promise<ConfigurationGroup[]> Array of configuration groups
     * @private
     */
    async getConfigurations() {
        try {
            const { data } = await this.configurationClient.getConfigurations(this.config.project);
            const entities = data.result?.entities ?? [];
            // Convert API response to domain model
            return entities.map(group => ({
                id: group.id ?? 0,
                title: group.title ?? '',
                configurations: group.configurations?.map(config => ({
                    id: config.id ?? 0,
                    title: config.title ?? ''
                })) ?? []
            }));
        }
        catch (error) {
            throw this.processError(error, 'Error getting configurations');
        }
    }
    /**
     * Create a configuration group
     * @param title Group title
     * @returns Promise<number | undefined> Created group ID
     * @private
     */
    async createConfigurationGroup(title) {
        try {
            const group = { title };
            const { data } = await this.configurationClient.createConfigurationGroup(this.config.project, group);
            return data.result?.id;
        }
        catch (error) {
            throw this.processError(error, 'Error creating configuration group');
        }
    }
    /**
     * Create a configuration in a group
     * @param title Configuration title
     * @param groupId Group ID
     * @returns Promise<number | undefined> Created configuration ID
     * @private
     */
    async createConfiguration(title, groupId) {
        try {
            const config = { title, group_id: groupId };
            const { data } = await this.configurationClient.createConfiguration(this.config.project, config);
            return data.result?.id;
        }
        catch (error) {
            throw this.processError(error, 'Error creating configuration');
        }
    }
    /**
     * Handle configuration creation based on config settings
     * @returns Promise<number[]> Array of configuration IDs
     * @private
     */
    async handleConfigurations() {
        if (!this.config.configurations?.values.length) {
            return [];
        }
        const configurationIds = [];
        try {
            // Get existing configuration groups
            const existingGroups = await this.getConfigurations();
            for (const configValue of this.config.configurations.values) {
                const { name: groupName, value: configName } = configValue;
                // Find existing group or create new one
                const group = existingGroups.find(g => g.title === groupName);
                let groupId;
                if (group) {
                    groupId = group.id;
                    this.logger.logDebug(`Found existing configuration group: ${groupName}`);
                }
                else {
                    if (this.config.configurations.createIfNotExists) {
                        const newGroupId = await this.createConfigurationGroup(groupName);
                        if (newGroupId) {
                            groupId = newGroupId;
                            this.logger.logDebug(`Created new configuration group: ${groupName} with ID: ${groupId}`);
                        }
                        else {
                            this.logger.logDebug(`Failed to create configuration group: ${groupName}, skipping`);
                            continue;
                        }
                    }
                    else {
                        this.logger.logDebug(`Configuration group not found: ${groupName}, skipping`);
                        continue;
                    }
                }
                if (groupId) {
                    // Check if configuration already exists in the group
                    const existingConfig = group?.configurations.find(c => c.title === configName);
                    if (!existingConfig) {
                        // Check if we should create configuration if it doesn't exist
                        if (this.config.configurations.createIfNotExists) {
                            const configId = await this.createConfiguration(configName, groupId);
                            if (configId) {
                                configurationIds.push(configId);
                            }
                            this.logger.logDebug(`Created configuration: ${configName} in group: ${groupName}`);
                        }
                        else {
                            this.logger.logDebug(`Configuration not found: ${configName} in group: ${groupName}, skipping`);
                        }
                    }
                    else {
                        if (existingConfig.id) {
                            configurationIds.push(existingConfig.id);
                        }
                        this.logger.logDebug(`Configuration already exists: ${configName} in group: ${groupName}`);
                    }
                }
            }
        }
        catch (error) {
            this.logger.logError('Error handling configurations:', error);
            // Don't throw error to avoid blocking test run creation
        }
        return configurationIds;
    }
    /**
     * Process error and throw QaseError
     * @param {Error | AxiosError} error
     * @param {string} message
     * @param {object} model
     * @private
     */
    processError(error, message, model) {
        if (!(0, is_axios_error_1.isAxiosError)(error)) {
            return new qase_error_1.QaseError(message, { cause: error });
        }
        const err = error;
        const errorData = err.response?.data;
        const status = err.response?.status;
        switch (status) {
            case ApiErrorCode.UNAUTHORIZED:
                return new qase_error_1.QaseError(`${message}: Unauthorized. Please check your API token.`);
            case ApiErrorCode.FORBIDDEN:
                return new qase_error_1.QaseError(`${message}: ${errorData?.errorMessage ?? 'Forbidden'}`);
            case ApiErrorCode.NOT_FOUND:
                return new qase_error_1.QaseError(`${message}: Not found.`);
            case ApiErrorCode.BAD_REQUEST:
            case ApiErrorCode.UNPROCESSABLE_ENTITY:
                return new qase_error_1.QaseError(`${message}: Bad request\n${JSON.stringify(errorData)}\nBody: ${JSON.stringify(model)}`);
            default:
                return new qase_error_1.QaseError(message, { cause: err });
        }
    }
}
exports.ClientV1 = ClientV1;
