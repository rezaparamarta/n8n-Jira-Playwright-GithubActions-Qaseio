"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TestOpsMultiReporter = void 0;
const chalk_1 = __importDefault(require("chalk"));
const uuid_1 = require("uuid");
const abstract_reporter_1 = require("./abstract-reporter");
const models_1 = require("../models");
const async_mutex_1 = require("async-mutex");
const clientV2_1 = require("../client/clientV2");
const defaultChunkSize = 200;
/**
 * Multi-project TestOps reporter. Sends test results to multiple Qase projects
 * with different test case IDs per project. Each project gets its own run.
 */
class TestOpsMultiReporter extends abstract_reporter_1.AbstractReporter {
    baseUrl;
    batchSize;
    /** Project code -> run ID */
    runIds = new Map();
    /** Project code -> API client for that project */
    clients = new Map();
    /** Project code -> queue of results to send */
    projectQueues = new Map();
    /** Project code -> first unsent index (for batch tracking) */
    firstIndexByProject = new Map();
    isTestRunReady = false;
    mutex = new async_mutex_1.Mutex();
    defaultProject;
    projectCodes;
    showPublicReportLink;
    constructor(logger, testopsOptions, multiConfig, withState, hostData, reporterName, frameworkPackage, environment, baseUrl, batchSize, showPublicReportLink) {
        super(logger);
        this.baseUrl = this.getBaseUrl(baseUrl ?? testopsOptions.api?.host);
        this.batchSize = batchSize ?? testopsOptions.batch?.size ?? defaultChunkSize;
        this.showPublicReportLink = showPublicReportLink ?? testopsOptions.showPublicReportLink;
        this.defaultProject =
            multiConfig.default_project ??
                (multiConfig.projects.length > 0 ? multiConfig.projects[0].code : '');
        this.projectCodes = multiConfig.projects
            .filter((p) => Boolean(p?.code))
            .map((p) => p.code);
        void withState; // reserved for future StateManager integration
        for (const proj of multiConfig.projects) {
            if (!proj?.code)
                continue;
            const projectOptions = this.buildProjectOptions(testopsOptions, proj);
            const env = proj.environment ?? environment;
            const client = new clientV2_1.ClientV2(logger, projectOptions, env, undefined, hostData, reporterName, frameworkPackage);
            this.clients.set(proj.code, client);
            this.projectQueues.set(proj.code, []);
            this.firstIndexByProject.set(proj.code, 0);
        }
    }
    buildProjectOptions(global, proj) {
        const opts = {
            project: proj.code,
            api: global.api,
            run: proj.run ?? global.run ?? {},
            plan: proj.plan ?? global.plan ?? {},
            uploadAttachments: global.uploadAttachments,
            defect: global.defect,
            configurations: global.configurations,
            statusFilter: global.statusFilter,
            showPublicReportLink: this.showPublicReportLink,
        };
        if (global.batch !== undefined) {
            opts.batch = global.batch;
        }
        return opts;
    }
    async startTestRun() {
        await this.checkOrCreateTestRuns();
    }
    async addTestResult(result) {
        if (result.execution.status === models_1.TestStatusEnum.failed) {
            const mapping = result.getTestopsProjectMapping?.() ?? result.testops_project_mapping ?? null;
            if (mapping) {
                for (const [projectCode, ids] of Object.entries(mapping)) {
                    for (const id of ids) {
                        this.showLink(projectCode, id, result.title);
                    }
                }
            }
            else {
                const ids = Array.isArray(result.testops_id) ? result.testops_id : [result.testops_id];
                for (const id of ids) {
                    if (id != null) {
                        this.showLink(this.defaultProject, id, result.title);
                    }
                }
            }
        }
        const release = await this.mutex.acquire();
        try {
            // Keep original in this.results for getTestResults / fallback
            if (result.execution.stacktrace) {
                result.execution.stacktrace = this.removeAnsiEscapeCodes(result.execution.stacktrace);
            }
            if (result.message) {
                result.message = this.removeAnsiEscapeCodes(result.message);
            }
            this.results.push(result);
            if (!this.isTestRunReady) {
                return;
            }
            for (const { code, ids } of this.getProjectsToUseForResult(result)) {
                const copy = this.copyResultForProject(result, code, ids);
                const queue = this.projectQueues.get(code);
                queue.push(copy);
                const first = this.firstIndexByProject.get(code) ?? 0;
                if (queue.length >= first + this.batchSize) {
                    await this.sendResultsForProject(code);
                }
            }
        }
        finally {
            release();
        }
    }
    /**
     * Get list of (projectCode, ids) for a result (multi-project mapping or legacy testops_id).
     * Caller must hold mutex when using projectQueues.
     */
    getProjectsToUseForResult(result) {
        const mapping = result.getTestopsProjectMapping?.() ?? result.testops_project_mapping ?? null;
        const projectsToUse = [];
        if (mapping && Object.keys(mapping).length > 0) {
            for (const [code, ids] of Object.entries(mapping)) {
                if (this.projectCodes.includes(code) && ids.length > 0) {
                    projectsToUse.push({ code, ids });
                }
            }
        }
        else {
            // Backward compatibility: use default project + testops_id, or send without case ID to default project
            const ids = Array.isArray(result.testops_id)
                ? result.testops_id
                : result.testops_id != null
                    ? [result.testops_id]
                    : [];
            if (this.defaultProject) {
                projectsToUse.push({ code: this.defaultProject, ids });
            }
        }
        return projectsToUse;
    }
    /**
     * Push a result into project queues (by project / case IDs). Used by addTestResult and by
     * sendResults() when results were set via setTestResults() (e.g. Cypress hooks in another process).
     * Caller must hold mutex.
     */
    distributeResultToProjectQueues(result) {
        for (const { code, ids } of this.getProjectsToUseForResult(result)) {
            const copy = this.copyResultForProject(result, code, ids);
            const queue = this.projectQueues.get(code);
            queue.push(copy);
        }
    }
    copyResultForProject(result, _projectCode, ids) {
        const copy = { ...result };
        copy.id = (0, uuid_1.v4)();
        copy.testops_id = ids.length === 0 ? null : ids.length === 1 ? ids[0] : ids;
        copy.testops_project_mapping = null;
        return copy;
    }
    async checkOrCreateTestRuns() {
        for (const code of this.projectCodes) {
            const client = this.clients.get(code);
            const runId = await client.createRun();
            this.runIds.set(code, runId);
            this.logger.logDebug(`[${code}] Run ID: ${runId}`);
        }
        this.isTestRunReady = true;
    }
    async sendResultsForProject(projectCode) {
        const queue = this.projectQueues.get(projectCode);
        const first = this.firstIndexByProject.get(projectCode) ?? 0;
        const client = this.clients.get(projectCode);
        const runId = this.runIds.get(projectCode);
        if (!queue || !client || runId === undefined) {
            return false;
        }
        const toSend = queue.slice(first, first + this.batchSize);
        if (toSend.length === 0) {
            return false;
        }
        try {
            await client.uploadResults(runId, toSend);
            this.firstIndexByProject.set(projectCode, first + toSend.length);
            this.logger.logDebug(`[${projectCode}] Sent ${toSend.length} results to Qase`);
            return true;
        }
        catch (error) {
            this.logger.logError(`[${projectCode}] Error sending results:`, error);
            return false;
        }
    }
    async sendResults() {
        const release = await this.mutex.acquire();
        try {
            // Only flush this.results when projectQueues are empty (e.g. Cypress: results set via
            // setTestResults() in another process). When addTestResult() already queued results
            // (same process, e.g. Cucumber), do not flush to avoid sending each result twice.
            const queuesEmpty = this.projectCodes.every((code) => (this.projectQueues.get(code)?.length ?? 0) === 0);
            if (this.results.length > 0 && this.isTestRunReady && queuesEmpty) {
                for (const result of this.results) {
                    this.distributeResultToProjectQueues(result);
                }
                this.results = [];
            }
            for (const code of this.projectCodes) {
                let sent;
                do {
                    sent = await this.sendResultsForProject(code);
                } while (sent);
            }
            for (const code of this.projectCodes) {
                this.projectQueues.set(code, []);
                this.firstIndexByProject.set(code, 0);
            }
        }
        finally {
            release();
        }
    }
    async publish() {
        // Do not hold mutex here: sendResults() and complete() acquire it themselves.
        // Holding mutex would deadlock when sendResults() tries to acquire the same mutex.
        await this.sendResults();
        await this.complete();
    }
    async complete() {
        const release = await this.mutex.acquire();
        try {
            // Send any remaining results per project
            for (const code of this.projectCodes) {
                let sent;
                do {
                    sent = await this.sendResultsForProject(code);
                } while (sent);
            }
            for (const code of this.projectCodes) {
                this.projectQueues.set(code, []);
                this.firstIndexByProject.set(code, 0);
            }
        }
        finally {
            release();
        }
        const completePromises = this.projectCodes.map(async (code) => {
            const client = this.clients.get(code);
            const runId = this.runIds.get(code);
            if (client && runId !== undefined) {
                try {
                    await client.completeRun(runId);
                    if (this.showPublicReportLink) {
                        try {
                            await client.enablePublicReport(runId);
                        }
                        catch {
                            // Error already logged in enablePublicReport
                        }
                    }
                    this.logger.log((0, chalk_1.default) `{green [${code}] Run ${runId} completed}`);
                }
                catch (error) {
                    this.logger.logError(`[${code}] Error completing run:`, error);
                }
            }
        });
        await Promise.all(completePromises);
    }
    async uploadAttachment(attachment) {
        // Attachments are uploaded per project when results are sent; use default project's client
        const client = this.clients.get(this.defaultProject);
        if (client) {
            return await client.uploadAttachment(attachment);
        }
        return '';
    }
    getBaseUrl(url) {
        if (!url || url === 'qase.io') {
            return 'https://app.qase.io';
        }
        return `https://${url.replace('api', 'app')}`;
    }
    showLink(projectCode, id, title) {
        const runId = this.runIds.get(projectCode);
        if (runId === undefined)
            return;
        const baseLink = `${this.baseUrl}/run/${projectCode}/dashboard/${runId}?source=logs&search=`;
        const link = id != null ? `${baseLink}${projectCode}-${id}` : `${baseLink}${encodeURI(title)}`;
        this.logger.log((0, chalk_1.default) `{blue See why this test failed: ${link}}`);
    }
}
exports.TestOpsMultiReporter = TestOpsMultiReporter;
